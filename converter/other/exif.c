/*--------------------------------------------------------------------------
  This file contains subroutines for use by Jpegtopnm to handle the
  EXIF header.

  The code is adapted from the program Jhead by Matthaias Wandel
  December 1999 - August 2000, and contributed to the public domain.
  Bryan Henderson adapted it to Netpbm in September 2001.  Bryan
  added more of Wandel's code, from Jhead 1.9 dated December 2002 in
  January 2003.

  Bryan fundamentally rewrote it in March 2023 because it wasn't properly
  dealing with the main image vs thumbnail IFDs.
--------------------------------------------------------------------------*/

/*
  N.B. "EXIF" refers to a whole image file format; some people think it is
  just the format of the camera model, orientation, etc. data within the
  image file.  EXIF is a subset of JFIF; an EXIF file is JFIF file
  containing an EXIF header in the form of a JFIF APP1 marker.

  An EXIF header is generated by some digital cameras and contains information
  about the circumstances of the creation of the image (camera settings,
  etc.).

  The EXIF header uses the TIFF format, only it contains only tag values and
  no actual image.

  Note that the image format called EXIF is simply JFIF with an EXIF header,
  i.e. a subformat of JFIF.

  See the EXIF specs at http://exif.org (2001.09.01).

  The basic format of the EXIF header is a sequence of IFDs (directories).  I
  believe the first IFD is always for the main image and the 2nd IFD is for a
  thumbnail image and is not present if there is no thumbnail image in the
  file.

  A directory is a sequence of tag/value pairs.

  Each IFD can contain SubIFD, as the value of an EXIF Offset or Interop
  Offset tag.

*/


#include "pm_config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>

#if MSVCRT
    #include <sys/utime.h>
#else
    #include <utime.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <errno.h>
#endif

#include "pm_c_util.h"
#include "pm.h"
#include "mallocvar.h"
#include "nstring.h"

#include "exif.h"

static double focalplaneXRes;
static bool haveXRes;
static double focalplaneUnits;
static int exifImageWidth;

typedef struct {
    unsigned short tag;
    const char * desc;
} TagTable;



/* Describes format descriptor */
static int const bytesPerFormat[] = {0,1,1,2,4,8,1,1,2,4,8,4,8};
#define NUM_FORMATS 12

#define FMT_BYTE       1
#define FMT_STRING     2
#define FMT_USHORT     3
#define FMT_ULONG      4
#define FMT_URATIONAL  5
#define FMT_SBYTE      6
#define FMT_UNDEFINED  7
#define FMT_SSHORT     8
#define FMT_SLONG      9
#define FMT_SRATIONAL 10
#define FMT_SINGLE    11
#define FMT_DOUBLE    12

/* Describes tag values */

#define TAG_EXIF_OFFSET       0x8769
#define TAG_INTEROP_OFFSET    0xa005

#define TAG_MAKE              0x010F
#define TAG_MODEL             0x0110

#define TAG_ORIENTATION       0x0112

#define TAG_XRESOLUTION       0x011A
#define TAG_YRESOLUTION       0x011B

#define TAG_EXPOSURETIME      0x829A
#define TAG_FNUMBER           0x829D

#define TAG_SHUTTERSPEED      0x9201
#define TAG_APERTURE          0x9202
#define TAG_MAXAPERTURE       0x9205
#define TAG_FOCALLENGTH       0x920A

#define TAG_DATETIME_ORIGINAL 0x9003
#define TAG_USERCOMMENT       0x9286

#define TAG_SUBJECT_DISTANCE  0x9206
#define TAG_FLASH             0x9209

#define TAG_FOCALPLANEXRES    0xa20E
#define TAG_FOCALPLANEUNITS   0xa210
#define TAG_EXIF_IMAGEWIDTH   0xA002
#define TAG_EXIF_IMAGELENGTH  0xA003

/* the following is added 05-jan-2001 vcs */
#define TAG_EXPOSURE_BIAS     0x9204
#define TAG_WHITEBALANCE      0x9208
#define TAG_METERING_MODE     0x9207
#define TAG_EXPOSURE_PROGRAM  0x8822
#define TAG_ISO_EQUIVALENT    0x8827
#define TAG_COMPRESSION_LEVEL 0x9102

#define TAG_THUMBNAIL_OFFSET  0x0201
#define TAG_THUMBNAIL_LENGTH  0x0202

static TagTable const tagTable[] = {
  {   0x100,   "ImageWidth"},
  {   0x101,   "ImageLength"},
  {   0x102,   "BitsPerSample"},
  {   0x103,   "Compression"},
  {   0x106,   "PhotometricInterpretation"},
  {   0x10A,   "FillOrder"},
  {   0x10D,   "DocumentName"},
  {   0x10E,   "ImageDescription"},
  {   0x10F,   "Make"},
  {   0x110,   "Model"},
  {   0x111,   "StripOffsets"},
  {   0x112,   "Orientation"},
  {   0x115,   "SamplesPerPixel"},
  {   0x116,   "RowsPerStrip"},
  {   0x117,   "StripByteCounts"},
  {   0x11A,   "XResolution"},
  {   0x11B,   "YResolution"},
  {   0x11C,   "PlanarConfiguration"},
  {   0x128,   "ResolutionUnit"},
  {   0x12D,   "TransferFunction"},
  {   0x131,   "Software"},
  {   0x132,   "DateTime"},
  {   0x13B,   "Artist"},
  {   0x13E,   "WhitePoint"},
  {   0x13F,   "PrimaryChromaticities"},
  {   0x156,   "TransferRange"},
  {   0x200,   "JPEGProc"},
  {   0x201,   "ThumbnailOffset"},
  {   0x202,   "ThumbnailLength"},
  {   0x211,   "YCbCrCoefficients"},
  {   0x212,   "YCbCrSubSampling"},
  {   0x213,   "YCbCrPositioning"},
  {   0x214,   "ReferenceBlackWhite"},
  {   0x828D,  "CFARepeatPatternDim"},
  {   0x828E,  "CFAPattern"},
  {   0x828F,  "BatteryLevel"},
  {   0x8298,  "Copyright"},
  {   0x829A,  "ExposureTime"},
  {   0x829D,  "FNumber"},
  {   0x83BB,  "IPTC/NAA"},
  {   0x8769,  "ExifOffset"},
  {   0x8773,  "InterColorProfile"},
  {   0x8822,  "ExposureProgram"},
  {   0x8824,  "SpectralSensitivity"},
  {   0x8825,  "GPSInfo"},
  {   0x8827,  "ISOSpeedRatings"},
  {   0x8828,  "OECF"},
  {   0x9000,  "ExifVersion"},
  {   0x9003,  "DateTimeOriginal"},
  {   0x9004,  "DateTimeDigitized"},
  {   0x9101,  "ComponentsConfiguration"},
  {   0x9102,  "CompressedBitsPerPixel"},
  {   0x9201,  "ShutterSpeedValue"},
  {   0x9202,  "ApertureValue"},
  {   0x9203,  "BrightnessValue"},
  {   0x9204,  "ExposureBiasValue"},
  {   0x9205,  "MaxApertureValue"},
  {   0x9206,  "SubjectDistance"},
  {   0x9207,  "MeteringMode"},
  {   0x9208,  "LightSource"},
  {   0x9209,  "Flash"},
  {   0x920A,  "FocalLength"},
  {   0x927C,  "MakerNote"},
  {   0x9286,  "UserComment"},
  {   0x9290,  "SubSecTime"},
  {   0x9291,  "SubSecTimeOriginal"},
  {   0x9292,  "SubSecTimeDigitized"},
  {   0xA000,  "FlashPixVersion"},
  {   0xA001,  "ColorSpace"},
  {   0xA002,  "ExifImageWidth"},
  {   0xA003,  "ExifImageLength"},
  {   0xA005,  "InteroperabilityOffset"},
  {   0xA20B,  "FlashEnergy"},                 /* 0x920B in TIFF/EP */
  {   0xA20C,  "SpatialFrequencyResponse"},  /* 0x920C    -  - */
  {   0xA20E,  "FocalPlaneXResolution"},     /* 0x920E    -  - */
  {   0xA20F,  "FocalPlaneYResolution"},      /* 0x920F    -  - */
  {   0xA210,  "FocalPlaneResolutionUnit"},  /* 0x9210    -  - */
  {   0xA214,  "SubjectLocation"},             /* 0x9214    -  - */
  {   0xA215,  "ExposureIndex"},            /* 0x9215    -  - */
  {   0xA217,  "SensingMethod"},            /* 0x9217    -  - */
  {   0xA300,  "FileSource"},
  {   0xA301,  "SceneType"},
  {      0, NULL}
} ;



typedef enum { ORDER_NORMAL, ORDER_MOTOROLA } ByteOrder;



static uint16_t
get16u(const void * const data,
       ByteOrder    const byteOrder) {
/*--------------------------------------------------------------------------
   Convert a 16 bit unsigned value from file's native byte order
--------------------------------------------------------------------------*/
    if (byteOrder == ORDER_MOTOROLA) {
        return (((const unsigned char *)data)[0] << 8) |
            ((const unsigned char *)data)[1];
    } else {
        return (((const unsigned char *)data)[1] << 8) |
            ((const unsigned char *)data)[0];
    }
}



static int32_t
get32s(const void * const data,
       ByteOrder    const byteOrder) {
/*--------------------------------------------------------------------------
   Convert a 32 bit signed value from file's native byte order
--------------------------------------------------------------------------*/
    if (byteOrder == ORDER_MOTOROLA) {
        return
            (((const char *)data)[0] << 24) |
            (((const unsigned char *)data)[1] << 16) |
            (((const unsigned char *)data)[2] << 8 ) |
            (((const unsigned char *)data)[3] << 0 );
    } else {
        return
            (((const char *)data)[3] << 24) |
            (((const unsigned char *)data)[2] << 16) |
            (((const unsigned char *)data)[1] << 8 ) |
            (((const unsigned char *)data)[0] << 0 );
    }
}



static uint32_t
get32u(const void * const data,
       ByteOrder    const byteOrder) {
/*--------------------------------------------------------------------------
   Convert a 32 bit unsigned value from file's native byte order
--------------------------------------------------------------------------*/
    return (uint32_t)get32s(data, byteOrder) & 0xffffffff;
}



static const char *
numberTraceValue(const void * const valueP,
                 int          const format,
                 unsigned int const byteCt,
                 ByteOrder    const byteOrder) {
/*--------------------------------------------------------------------------
   Format for display a number represented in any of the numeric formats
--------------------------------------------------------------------------*/
    const char * retval;

    switch(format) {
    case FMT_SBYTE:
    case FMT_BYTE:
        pm_asprintf(&retval, "%02x", *(unsigned char *)valueP);
        break;
    case FMT_USHORT:
        pm_asprintf(&retval, "%d",get16u(valueP, byteOrder));
        break;
    case FMT_ULONG:
    case FMT_SLONG:
        pm_asprintf(&retval, "%d",get32s(valueP, byteOrder));
        break;
    case FMT_SSHORT:
        pm_asprintf(&retval, "%hd",(signed short)get16u(valueP, byteOrder));
        break;
    case FMT_URATIONAL:
    case FMT_SRATIONAL:
        pm_asprintf(&retval, "%d/%d",
                    get32s(valueP, byteOrder),
                    get32s(4+(char *)valueP,
                           byteOrder));
        break;
    case FMT_SINGLE:
        pm_asprintf(&retval, "%f",(double)*(float *)valueP);
        break;
    case FMT_DOUBLE:
        pm_asprintf(&retval, "%f",*(double *)valueP);
        break;
    default: {
        char * hex;

        MALLOCARRAY(hex, byteCt*2 + 1);
        if (!hex)
                retval = pm_strsol;
        else {
            unsigned int i;
            for (i = 0; i < byteCt && i < 16; ++i) {
                sprintf(&hex[i*2], "%02x",
                        ((const unsigned char *)valueP)[i]);
            }
            pm_asprintf(&retval, "Unknown format %d: %s", format, hex);
        }
    }
    }
    return retval;
}



static double
numericValue(const void * const valuePtr,
             int          const format,
             ByteOrder    const byteOrder) {
/*--------------------------------------------------------------------------
   Evaluate number, be it int, rational, or float from directory.
--------------------------------------------------------------------------*/
    double value;

    switch(format) {
    case FMT_SBYTE:
        value = *(signed char *)valuePtr;
        break;
    case FMT_BYTE:
        value = *(unsigned char *)valuePtr;
        break;
    case FMT_USHORT:
        value = get16u(valuePtr, byteOrder);
        break;
    case FMT_ULONG:
        value = get32u(valuePtr, byteOrder);
        break;
    case FMT_URATIONAL:
    case FMT_SRATIONAL: {
        int num, den;
        num = get32s(valuePtr, byteOrder);
        den = get32s(4+(char *)valuePtr, byteOrder);
        value = den == 0 ? 0 : (double)(num/den);
    } break;
    case FMT_SSHORT:
        value = (signed short)get16u(valuePtr, byteOrder);
        break;
    case FMT_SLONG:
        value = get32s(valuePtr, byteOrder);
        break;

    /* Not sure if this is correct (never seen float used in Exif format) */
    case FMT_SINGLE:
        value = (double)*(float *)valuePtr;
        break;
    case FMT_DOUBLE:
        value = *(double *)valuePtr;
        break;
    }
    return value;
}



static const char *
stringTraceValue(const unsigned char * const value,
                 unsigned int          const valueSz) {

    const char * retval;
    char * buffer;

    MALLOCARRAY(buffer, valueSz + 1);
    if (!buffer)
        retval = pm_strsol;
    else {
        unsigned int i;
        bool noPrint;
            /* We're in a sequence of unprintable characters.  We put one
               '?' in the value for the whole sequence.
            */
        unsigned int outCursor;

        outCursor = 0;  /* initial value */

        for (i = 0, noPrint = false; i < valueSz; ++i) {
            if (ISPRINT(value[i])) {
                buffer[outCursor++] = value[i];
                noPrint = false;
            } else {
                if (!noPrint) {
                    buffer[outCursor++] = '?';
                    noPrint = true;
                }
            }
        }
        buffer[outCursor++] = '\0';

        retval = buffer;
    }
    return retval;
}



static void
traceTag(int                   const tag,
         int                   const format,
         const unsigned char * const value,
         unsigned int          const valueSz,
         ByteOrder             const byteOrder) {

    const char * tagNm;
    const char * tagValue;
    unsigned int i;

    for (i = 0, tagNm = NULL;tagTable[i].tag; ++i) {
        if (tagTable[i].tag == tag)
            tagNm = pm_strdup(tagTable[i].desc);
    }

    if (!tagNm)
        pm_asprintf(&tagNm, "Unknown Tag %04x", tag);

    /* Show tag value. */
    switch (format) {

    case FMT_UNDEFINED:
        /* Undefined is typically an ascii string. */
    case FMT_STRING: {
        tagValue = stringTraceValue(value, valueSz);
    } break;

    default:
        /* Handle arrays of numbers later (will there ever be?)*/
        tagValue = numberTraceValue(value, format, valueSz, byteOrder);
    }
    pm_message("%s = \"%s\"", tagNm, tagValue);

    pm_strfree(tagValue);
    pm_strfree(tagNm);
}



/* Forward declaration for recursion */

static void
processIfd(const unsigned char *  const exifData,
           unsigned int           const exifLength,
           unsigned int           const dirOffset,
           exif_ifd *             const ifdP,
           ByteOrder              const byteOrder,
           bool                   const wantTagTrace,
           const char **          const errorP);


static void
processDirEntry(const unsigned char *  const dirEntry,
                const unsigned char *  const exifData,
                unsigned int           const exifLength,
                ByteOrder              const byteOrder,
                bool                   const wantTagTrace,
                exif_ifd *             const ifdP,
                const char **          const errorP) {

    int const tag        = get16u(&dirEntry[0], byteOrder);
    int const format     = get16u(&dirEntry[2], byteOrder);
    int const components = get32u(&dirEntry[4], byteOrder);

    const unsigned char * valuePtr;
        /* This actually can point to a variety of things; it must be cast to
           other types when used.  But we use it as a byte-by-byte cursor, so
           we declare it as a pointer to a generic byte here.
        */
    unsigned int valueSz;

    *errorP = NULL;  /* initial assumption */

    if ((format-1) >= NUM_FORMATS) {
        /* (-1) catches illegal zero case as unsigned underflows
           to positive large.
        */
        pm_message("Illegal number format %d for tag %04x", format, tag);
        return;
    }

    valueSz = components * bytesPerFormat[format];

    if (valueSz > 4) {
        unsigned const offsetVal = get32u(&dirEntry[8], byteOrder);
        /* If its bigger than 4 bytes, the dir entry contains an offset.*/
        if (offsetVal + valueSz > exifLength) {
            /* Bogus pointer offset and / or bytecount value */
            pm_message("Illegal pointer offset value in EXIF "
                       "for tag %04x.  "
                       "Offset %d bytes %d ExifLen %d\n",
                       tag, offsetVal, valueSz, exifLength);
            return;
        }
        valuePtr = &exifData[offsetVal];
    } else {
        /* 4 bytes or less and value is in the dir entry itself */
        valuePtr = &dirEntry[8];
    }

    if (wantTagTrace)
        traceTag(tag, format, valuePtr, valueSz, byteOrder);

    /* Extract useful components of tag */
    switch (tag) {

    case TAG_MAKE:
        STRSCPY(ifdP->cameraMake, (const char*)valuePtr);
        break;

    case TAG_MODEL:
        STRSCPY(ifdP->cameraModel, (const char*)valuePtr);
        break;

    case TAG_XRESOLUTION:
        ifdP->xResolution =
            numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_YRESOLUTION:
        ifdP->yResolution =
            numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_DATETIME_ORIGINAL:
        STRSCPY(ifdP->dateTime, (const char*)valuePtr);
        break;

    case TAG_USERCOMMENT: {
        /* Olympus has this padded with trailing spaces.  We stop the copy
           where those start.
        */
        const char * const value = (const char *)valuePtr;

        unsigned int cursor;
        unsigned int outCursor;
        unsigned int end;

        for (end = valueSz; end > 0 && value[end] == ' '; --end);

        /* Skip "ASCII" if it is there */
        if (end >= 5 && memeq(value, "ASCII", 5))
            cursor = 5;
        else
            cursor = 0;

        /* Skip consecutive blanks and NULs */

        for (;
             cursor < valueSz &&
                 (value[cursor] == '\0' || value[cursor] == ' ');
             ++cursor);

        /* Copy the rest as the comment */

        for (outCursor = 0;
             cursor < end && outCursor < MAX_COMMENT-1;
             ++cursor)
            ifdP->comments[outCursor++] = value[cursor];

        ifdP->comments[outCursor++] = '\0';
    } break;

    case TAG_FNUMBER:
        /* Simplest way of expressing aperture, so I trust it the most.
           (overwrite previously computed value if there is one)
        */
        ifdP->apertureFNumber =
            (float)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_APERTURE:
    case TAG_MAXAPERTURE:
        /* More relevant info always comes earlier, so only use this field if
           we don't have appropriate aperture information yet.
        */
        if (ifdP->apertureFNumber == 0) {
            ifdP->apertureFNumber = (float)
                exp(numericValue(valuePtr, format, byteOrder)
                    * log(2) * 0.5);
        }
        break;

    case TAG_FOCALLENGTH:
        /* Nice digital cameras actually save the focal length
           as a function of how farthey are zoomed in.
        */

        ifdP->focalLength =
            (float)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_SUBJECT_DISTANCE:
        /* Inidcates the distacne the autofocus camera is focused to.
           Tends to be less accurate as distance increases.
        */
        ifdP->distance =
            (float)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_EXPOSURETIME:
        /* Simplest way of expressing exposure time, so I
           trust it most.  (overwrite previously computd value
           if there is one)
        */
        ifdP->exposureTime =
            (float)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_SHUTTERSPEED:
        /* More complicated way of expressing exposure time,
           so only use this value if we don't already have it
           from somewhere else.
        */
        if (ifdP->exposureTime == 0) {
            ifdP->exposureTime = (float)
                (1/exp(numericValue(valuePtr, format, byteOrder)
                       * log(2)));
        }
        break;

    case TAG_FLASH:
        if ((int)numericValue(valuePtr, format, byteOrder) & 0x7) {
            ifdP->flashUsed = TRUE;
        }else{
            ifdP->flashUsed = FALSE;
        }
        break;

    case TAG_ORIENTATION:
        ifdP->orientation =
            (int)numericValue(valuePtr, format, byteOrder);
        if (ifdP->orientation < 1 ||
            ifdP->orientation > 8) {
            pm_message("Undefined rotation value %d",
                       ifdP->orientation);
            ifdP->orientation = 0;
        }
        break;

    case TAG_EXIF_IMAGELENGTH:
    case TAG_EXIF_IMAGEWIDTH:
        /* Use largest of height and width to deal with images
           that have been rotated to portrait format.
        */
        exifImageWidth =
            MIN(exifImageWidth,
                (int)numericValue(valuePtr, format, byteOrder));
        break;

    case TAG_FOCALPLANEXRES:
        haveXRes = true;
        focalplaneXRes = numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_FOCALPLANEUNITS:
        switch((int)numericValue(valuePtr, format, byteOrder)) {
        case 1: focalplaneUnits = 25.4; break; /* 1 inch */
        case 2:
            /* According to the information I was using, 2
               means meters.  But looking at the Cannon
               powershot's files, inches is the only
               sensible value.
            */
            focalplaneUnits = 25.4;
            break;

        case 3: focalplaneUnits = 10;   break;  /* 1 centimeter*/
        case 4: focalplaneUnits = 1;    break;  /* 1 millimeter*/
        case 5: focalplaneUnits = .001; break;  /* 1 micrometer*/
        }
        break;

        /* Remaining cases contributed by: Volker C. Schoech
           (schoech@gmx.de)
        */

    case TAG_EXPOSURE_BIAS:
        ifdP->exposureBias =
            (float) numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_WHITEBALANCE:
        ifdP->whiteBalance =
            (int)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_METERING_MODE:
        ifdP->meteringMode =
            (int)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_EXPOSURE_PROGRAM:
        ifdP->exposureProgram =
            (int)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_ISO_EQUIVALENT:
        ifdP->isoEquivalent =
            (int)numericValue(valuePtr, format, byteOrder);
        if ( ifdP->isoEquivalent < 50 )
            ifdP->isoEquivalent *= 200;
        break;

    case TAG_COMPRESSION_LEVEL:
        ifdP->compressionLevel =
            (int)numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_THUMBNAIL_OFFSET:
        ifdP->thumbnailOffset = (unsigned int)
            numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_THUMBNAIL_LENGTH:
        ifdP->thumbnailLength = (unsigned int)
            numericValue(valuePtr, format, byteOrder);
        break;

    case TAG_EXIF_OFFSET:
    case TAG_INTEROP_OFFSET: {
        unsigned int const subdirOffset = get32u(valuePtr, byteOrder);
        if (subdirOffset >= exifLength)
            pm_message("Illegal exif or interop offset "
                       "directory link.  Offset is %u, "
                       "but Exif data is only %u bytes.",
                       subdirOffset, exifLength);
        else {
            const char * error;
            processIfd(exifData, exifLength, subdirOffset,
                       ifdP, byteOrder, wantTagTrace,
                       &error);

            if (error) {
                pm_asprintf(errorP, "Failed to process "
                            "ExifOffset/InteropOffset tag.  %s", error);
                pm_strfree(error);
            }
        }
    } break;
    }
}



static void
processIfd(const unsigned char *  const exifData,
           unsigned int           const exifLength,
           unsigned int           const dirOffset,
           exif_ifd *             const ifdP,
           ByteOrder              const byteOrder,
           bool                   const wantTagTrace,
           const char **          const errorP) {
/*--------------------------------------------------------------------------
   Process one of the nested EXIF IFDs (Image File Directory).
--------------------------------------------------------------------------*/
    const unsigned char * const dirStart = exifData + dirOffset;
    unsigned int const numDirEntries = get16u(&dirStart[0], byteOrder);

    unsigned int de;

    *errorP = NULL;  /* initial value */

    #define DIR_ENTRY_ADDR(Start, Entry) (Start + 2 + 12*(Entry))

    if (wantTagTrace)
        pm_message("Directory with %u entries", numDirEntries);

    ifdP->thumbnailOffset = 0;      /* initial value */
    ifdP->thumbnailLength = 0;      /* initial value */

    for (de = 0; de < numDirEntries && !*errorP; ++de) {
        const char * error;
        processDirEntry(DIR_ENTRY_ADDR(dirStart, de), exifData, exifLength,
                        byteOrder, wantTagTrace, ifdP,
                        &error);

        if (error) {
            pm_asprintf(errorP, "Failed to process tag %u.  %s",
                        de, error);
            pm_strfree(error);
        }
    }

    {
        /* Recursively process the next directory in the chain, if there is
           one
        */
        if (DIR_ENTRY_ADDR(dirStart, numDirEntries) + 4 <=
            exifData + exifLength) {
            unsigned int const subdirOffset =
                get32u(dirStart + 2 + 12*numDirEntries, byteOrder);
            if (subdirOffset) {
                const unsigned char * const subdirStart =
                    exifData + subdirOffset;
                if (subdirStart > exifData + exifLength) {
                    if (subdirStart < exifData + exifLength + 20) {
                        /* Jhead 1.3 or earlier would crop the whole directory!
                           As Jhead produces this form of format incorrectness,
                           I'll just let it pass silently.
                        */
                        if (wantTagTrace)
                            pm_message("Thumbnail removed with "
                                       "Jhead 1.3 or earlier");
                    } else {
                        pm_message("Illegal subdirectory link");
                    }
                } else {
                    const char * error;
                    /* Dummy, since this code will be deleted */
                    if (subdirOffset <= exifLength)
                        processIfd(exifData, exifLength, subdirOffset,
                                   ifdP, byteOrder, wantTagTrace,
                                   &error);
                }
            }
        } else {
            /* The exif header ends before the last next directory pointer. */
        }
    }

    if (ifdP->thumbnailLength && ifdP->thumbnailOffset) {
        if (ifdP->thumbnailOffset + ifdP->thumbnailLength <= exifLength) {
            /* The thumbnail pointer appears to be valid.  Store it. */
            ifdP->thumbnail     = exifData + ifdP->thumbnailOffset;
            ifdP->thumbnailSize = ifdP->thumbnailLength;

            if (wantTagTrace) {
                pm_message("Thumbnail size: %u bytes", ifdP->thumbnailSize);
            }
        }
    }
}



void
exif_parse(const unsigned char * const exifData,
           unsigned int          const length,
           exif_ImageInfo *      const imageInfoP,
           bool                  const wantTagTrace,
           const char **         const errorP) {
/*--------------------------------------------------------------------------
  Interpret an EXIF APP1 marker

  'exifData' is the actual Exif data; it does not include the
  "Exif" identifier and length field that often prefix Exif data.

  'length' is the length of the Exif section.
--------------------------------------------------------------------------*/
    ByteOrder byteOrder;
    unsigned int firstOffset;

    *errorP = NULL;  /* initial assumption */

    if (wantTagTrace)
        fprintf(stderr, "Exif header %u bytes long\n", length);

    if (memeq(exifData + 0, "II" , 2)) {
        if (wantTagTrace)
            fprintf(stderr, "Exif header in Intel order\n");
        byteOrder = ORDER_NORMAL;
    } else {
        if (memeq(exifData + 0, "MM", 2)) {
            if (wantTagTrace)
                fprintf(stderr, "Exif header in Motorola order\n");
            byteOrder = ORDER_MOTOROLA;
        } else {
            pm_asprintf(errorP, "Invalid alignment marker in Exif "
                        "data.  First two bytes are '%c%c' (0x%02x%02x) "
                        "instead of 'II' or 'MM'.",
                        exifData[0], exifData[1], exifData[0], exifData[1]);
        }
    }
    if (!*errorP) {
        unsigned short const start = get16u(exifData + 2, byteOrder);
        /* Check the next value for correctness. */
        if (start != 0x002a) {
            pm_asprintf(errorP, "Invalid Exif header start.  "
                        "two bytes after the alignment marker "
                        "should be 0x002a, but is 0x%04x",
                        start);
        }
    }
    if (!*errorP) {
        const char * error;

        firstOffset = get32u(exifData + 4, byteOrder);
        if (firstOffset < 8 || firstOffset > 16) {
            /* I used to ensure this was set to 8 (website I used
               indicated its 8) but PENTAX Optio 230 has it set
               differently, and uses it as offset. (Sept 11 2002)
                */
            pm_message("Suspicious offset of first IFD value in Exif header");
        }

        imageInfoP->mainImage.comments[0] = '\0';
            /* Initial value - null string */

        haveXRes = FALSE;  /* Initial assumption */
        focalplaneUnits = 0;
        exifImageWidth = 0;

        processIfd(exifData, length, firstOffset,
                   &imageInfoP->mainImage, byteOrder, wantTagTrace,
                   &error);

        if (error) {
            pm_asprintf(errorP, "Failed to process IFD.  %s", error);
            pm_strfree(error);
        } else {
            /* Compute the CCD width, in millimeters. */
            if (haveXRes && exifImageWidth) {
                imageInfoP->mainImage.haveCCDWidth = 1;
                imageInfoP->mainImage.ccdWidth =
                    (float)(exifImageWidth * focalplaneUnits / focalplaneXRes);
            } else
                imageInfoP->mainImage.haveCCDWidth = 0;
        }
    }
}



static void
showIfd(const exif_ifd * const ifdP) {

    if (ifdP->cameraMake[0]) {
        pm_message("Camera make  : %s", ifdP->cameraMake);
        pm_message("Camera model : %s", ifdP->cameraModel);
    }
    if (ifdP->dateTime[0])
        pm_message("Date/Time    : %s", ifdP->dateTime);

    pm_message("Resolution   : %f x %f",
               ifdP->xResolution, ifdP->yResolution);

    if (ifdP->orientation > 1) {
        /* Note that orientation is usually understood to be the orientation
           of the camera, not of the image.  The top, bottom, left, and right
           sides of an image are defined in the JFIF format.

           But values such as "flip horizontal" make no sense for that.
        */
        static const char * orientTab[9] = {
            "Undefined",
            "Normal",           /* 1 */
            "flip horizontal",  /* left right reversed mirror */
            "rotate 180",       /* 3 */
            "flip vertical",    /* upside down mirror */
            "transpose",    /* Flipped about top-left <--> bottom-right axis.*/
            "rotate 90",        /* rotate 90 cw to right it. */
            "transverse",   /* flipped about top-right <--> bottom-left axis */
            "rotate 270",       /* rotate 270 to right it. */
        };

        pm_message("Camera orientation  : %s",
                   orientTab[ifdP->orientation]);
    }

    if (ifdP->isColor == 0)
        pm_message("Color/bw     : Black and white");

    if (ifdP->flashUsed >= 0)
        pm_message("Flash used   : %s",
                   ifdP->flashUsed ? "Yes" :"No");

    if (ifdP->focalLength) {
        const char * mm35equiv;

        if (ifdP->haveCCDWidth) {
            pm_asprintf(&mm35equiv, "  (35mm equivalent: %dmm)",
                        (int) (ifdP->focalLength/ifdP->ccdWidth*36 + 0.5));
        } else
            mm35equiv = pm_strdup("");

        pm_message("Focal length : %4.1fmm %s",
                   (double)ifdP->focalLength, mm35equiv);

        pm_strfree(mm35equiv);
    }

    if (ifdP->haveCCDWidth)
        pm_message("CCD width    : %2.4fmm", (double)ifdP->ccdWidth);

    if (ifdP->exposureTime) {
        const char * timeDisp;
        const char * recipDisp;

        if (ifdP->exposureTime < 0.010) {
            pm_asprintf(&timeDisp, "%6.4f s", (double)ifdP->exposureTime);
        } else {
            pm_asprintf(&timeDisp, "%5.3f s", (double)ifdP->exposureTime);
        }
        if (ifdP->exposureTime <= 0.5) {
            pm_asprintf(&recipDisp, " (1/%d)",
                        (int)(0.5 + 1/ifdP->exposureTime));
        } else
            recipDisp = pm_strdup("");

        pm_message("Exposure time: %s %s", timeDisp, recipDisp);

        pm_strfree(recipDisp);
        pm_strfree(timeDisp);
    }
    if (ifdP->apertureFNumber) {
        pm_message("Aperture     : f/%3.1f", (double)ifdP->apertureFNumber);
    }
    if (ifdP->distance) {
        if (ifdP->distance < 0)
            pm_message("Focus dist.  : Infinite");
        else
            pm_message("Focus dist.  :%5.2fm", (double)ifdP->distance);
    }

    if (ifdP->isoEquivalent)
        pm_message("ISO equiv.   : %2d",(int)ifdP->isoEquivalent);

    if (ifdP->exposureBias)
        pm_message("Exposure bias:%4.2f", (double)ifdP->exposureBias);

    if (ifdP->whiteBalance) {
        const char * whiteBalanceDisp;

        switch(ifdP->whiteBalance) {
        case 1:  whiteBalanceDisp = "sunny";         break;
        case 2:  whiteBalanceDisp = "fluorescent";   break;
        case 3:  whiteBalanceDisp = "incandescent";  break;
        default: whiteBalanceDisp = "cloudy";        break;
        }
        pm_message("Whitebalance : %s", whiteBalanceDisp);
    }
    if (ifdP->meteringMode) {
        const char * meteringModeDisp;

        switch(ifdP->meteringMode) {
        case 2: meteringModeDisp = "center weight";  break;
        case 3: meteringModeDisp = "spot";           break;
        case 5: meteringModeDisp = "matrix";         break;
        }
        pm_message("Metering Mode: %s", meteringModeDisp);
    }
    if (ifdP->exposureProgram) {
        const char * exposureDisp;

        switch(ifdP->exposureProgram) {
        case 2: exposureDisp = "program (auto)";                break;
        case 3: exposureDisp = "aperture priority (semi-auto)"; break;
        case 4: exposureDisp = "shutter priority (semi-auto)";  break;
        }
        pm_message("Exposure     : %s", exposureDisp);
    }
    if (ifdP->compressionLevel) {
        const char * jpegQualityDisp;

        switch(ifdP->compressionLevel) {
        case 1: jpegQualityDisp = "basic";  break;
        case 2: jpegQualityDisp = "normal"; break;
        case 4: jpegQualityDisp = "fine";   break;
       }
        pm_message("Jpeg Quality  : %s", jpegQualityDisp);
    }

    if (ifdP->comments[0]) {
        char * buffer;

        MALLOCARRAY(buffer, strlen(ifdP->comments) + 1);

        if (!buffer)
            pm_message("Out of memory allocating a buffer for %u "
                       "characters of comments",
                       (unsigned)strlen(ifdP->comments));
        else {
            unsigned int i;
            unsigned int outCursor;

            strcpy(buffer, "Comment:  ");  /* Permanently in buffer */

            outCursor = 10;  /* initial value */

            for (i = 0; ifdP->comments[i]; ++i) {
                char const c = ifdP->comments[i];
                if (c == '\n') {
                    buffer[outCursor++] = '\0';
                    pm_message("%s", buffer);
                    outCursor = 10;
                } else
                    buffer[outCursor++] = c;
            }
            if (outCursor > 10)
                pm_message("%s", buffer);

            free(buffer);
        }
    }
}



void
exif_showImageInfo(const exif_ImageInfo * const imageInfoP) {
/*--------------------------------------------------------------------------
   Show the collected image info, displaying camera F-stop and shutter
   speed in a consistent and legible fashion.
--------------------------------------------------------------------------*/

    showIfd(&imageInfoP->mainImage);
}



